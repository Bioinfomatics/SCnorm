%\VignetteIndexEntry{SCnorm Vignette}
%\VignettePackage{SCnorm}
%\VignetteEngine{knitr::knitr}

\documentclass{article}
\usepackage{graphicx, graphics, epsfig,setspace,amsmath, amsthm}
\usepackage{natbib}
\usepackage{moreverb}

<<style-knitr, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex()
@
  
\begin{document}

\title{SCnorm: robust normalization of
    single-cell RNA-seq data}
\author{Rhonda Bacher and Christina Kendziorski}
\maketitle
\tableofcontents
\setcounter{tocdepth}{2}

\section{Introduction}
\label{sec:intro}
SCnorm (as detailed in Bacher* and Chu* {\it et al.}, {{2017}}) 
is a quantile-regression based approach for robust normalization of 
single-cell RNA-seq data. Normalization methods typically estimate a scale factor per sample to 
adjust for differences in the amount of sequencing each sample receives. Increases in sequencing 
typically lead to proportional increases in gene counts; however, in scRNA-seq data 
sequencing depth does not affect gene counts equally. SCnorm groups genes based on their count-depth 
relationship then within each group applies a quantile regression to 
estimate scaling factors which will remove the effect of sequencing depth from
the counts. 
  
\section{Run SCnorm}
\label{sec:quickstart}
Before analysis can proceed, the SCnorm package must be installed.

<<eval=FALSE, echo=TRUE>>=
install.packages("SCnorm_x.x.x.tar.gz", repos=NULL, type="source")
#OR
library(devtools)
devtools::install_github("rhondabacher/SCnorm")

@

After successful installation, the package must be loaded into the working
space:

<<eval=TRUE, echo=TRUE,warning=FALSE>>=
library(SCnorm)
@

\subsection{Required inputs}

{\bf Data}:  Input to SCnorm may be either of class SummarizedExperiment or as a matrix.
If a matrix input is used, then \verb+Data+ should be a $G-by-S$ matrix containing the
expression values for each gene and each cell,
where $G$ is the number of genes and $S$ is the number of cells/samples. The
matrix should contain estimates of gene expression such as those obtained from RSEM, HTSeq,
Cufflinks, Salmon or similar approaches.

\noindent The object \verb+ExampleData+ is a simulated data matrix containing
5,000 rows of genes and 90 columns of cells.

<<eval=TRUE>>=
data(ExampleData)

str(ExampleData)
@

If the input is of a SummarizedExperiment class, then the main assay should contain the expression matrix
to be normalized and the \Rcode{colData} should contain the cell/sample names:

<<eval=TRUE>>=
ExampleData <- SummarizedExperiment::SummarizedExperiment(assays=list("Counts"=ExampleData),
                                      colData=data.frame(colnames(ExampleData)))

@

{\bf Conditions}: The object \verb+Conditions+ should be a vector of length $S$
indicating which condition/group each cell belongs to. The order of this vector
should match the order of the columns in the \verb+Data+ matrix.

<<eval=TRUE>>=
Conditions = rep(c(1), each= 90)
str(Conditions)
@



\subsection{SCnorm: Check count-depth relationship}
\label{sec:checkData}
Before normalizing using SCnorm, it is advised to check the count-depth
relationship in your data. If all genes have a similar relationship then
a global strategy such as median-by-ratio in the DESeq package or TMM in edgeR will be
adequate. However, in our paper we show that a count-depth relationship that
varies among genes leads to poor normalization when using global scaling
strategies, in which case we strongly recommend proceeding with the
normalization provided by SCnorm.

The function below will estimate the count-depth relationship for all
genes. Genes are first divided into ten equally sized groups based on their non-zero median expression,
then the density of slopes for each group is plot. We recommend checking a variety of
filter options, in case you find that only genes expressed in very few cells or
very low expressors are the main concern.

The evaluation plot will be saved as a PDF in the current directory with
file name specified in OutputName, or the path and file name may be supplied in
OutputName (e.g., OutputName = "\~/Desktop/FavoriteData/check\_myData").

<<eval=TRUE>>=
checkCountDepth(Data = ExampleData, Conditions = Conditions,
                 OutputName = "check_exampleData",
                 FilterCellProportion = .1, NCores=3)
@

\begin{figure}[h!]
\centering
\includegraphics[width=.4\textwidth]{check_exampleData_count-depth_evaluation.pdf}
\caption{Evaluation of count-depth relationship in un-normalized data.}
\end{figure}



\newpage
It can also be used to evaluate data normalized by other methods:
<<eval=TRUE>>=
ExampleData = getCounts(ExampleData)
# Total Count normalization, Counts Per Million, CPM.
ExampleData.Norm <- t((t(ExampleData) / colSums(ExampleData)) *
                        mean(colSums(ExampleData)))

checkCountDepth(Data = ExampleData,
                NormalizedData = ExampleData.Norm,
                Condition = Conditions,
                OutputName = "check_exampleDataNorm",
                FilterCellProportion = .1,
                FilterExpression = 2, NCores=3)

@

\begin{figure}[h!]
\centering
\includegraphics[width=.4\textwidth]{check_exampleDataNorm_count-depth_evaluation.pdf}
\caption{Evaluation of count-depth relationship in counts per million
normalized example data.}
\end{figure}

\newpage

\subsection{SCnorm: Normalization}
\label{sec:Normalization}
SCnorm will normalize across cells to remove the effect of sequencing
depth on the counts and return the normalized expression counts, a list of
genes which were not considered in the normalization due to filter options, and optionally an
additional matrix of scale factors (default = FALSE).The default filter
for SCnorm only considers genes having at least 10 non-zero expression values. The user may
wish to adjust the filter and may do so by changing the value of FilterCellNum.


If SavePDF=TRUE is specified, the progress plots of SCnorm
will be created and saved to the directly and file names given to MyNormalizedData
for each value of $K$ tried. Setting SavePDF=FALSE will print plots to screen or
current device.

Normalized data can be accessed using the \Rclass{getResults()} function.

<<eval=TRUE>>=
Conditions = rep(c(1), each= 90)
DataNorm <- SCnorm(ExampleData, Conditions,
                   OutputName = "MyNormalizedData",
                   SavePDF=TRUE,
                   FilterCellNum = 10,
                   NCores=3)
NormalizedData <- getResults(DataNorm)
NormalizedData[1:5,1:5]

@

The list of genes not normalized according to the filter specifications may be obtained by:
<<eval=TRUE>>=
GenesNotNormalized <- getResults(DataNorm, type="GenesFilteredOut")
str(GenesNotNormalized)
@

If scale factors should be returned, then they can be accessed using:
<<eval=TRUE>>=
ScaleFactors <- getResults(DataNorm, type="ScaleFactors")
str(ScaleFactors)
@

\subsection{Evaluate choice of \textit{K}}
\label{sec:NormalizationK}

SCnorm first fits the model for $K = 1$, and sequentially increases K until a
satisfactory stopping point is reached. For each value of $K$, SCnorm will
estimate the count-depth relationship on the normalized counts. Gene evaluation
groups are formed by splitting genes into 10 groups based on their
non-zero median un-normalized expression. For each group the mode of the normalized
count-depth relationship is estimated. If the absolute value of the maximum mode
is < .1, then $K$ is selected, otherwise $K$ is increased by one.


\begin{figure}[h!]
\centering
\includegraphics[width=.5\textwidth]{MyNormalizedData_k_evaluation.pdf}
\caption{Evaluation of K}
\end{figure}



In Figure 5, $K = 4$ is chosen, once all 10 slope densities have
absolute value of slope mode < .1.


\section{SCnorm: Multiple Conditions}
When more than one condition is present SCnorm will first normalize
each condition independently then apply a scaling procedure between the conditions.
In this step the assumption is that most genes are not differentially expressed (DE) between
cells, that any systematic differences in expression across the
majority of genes is due to technical bias and should be removed.

Zeros are not included in the estimations of scaling factors across conditions by default, this will make the means across conditions equal when zeros are not considered (which can then used for downstream differential expression analyses with \Biocpkg{MAST}, for example). However, if the proportion of zeros is very unequal between conditions and the user plans to use a downstream tool which includes zeros in the analysis (such as \Biocpkg{DESeq} or \Biocpkg{edgeR}), then the scaling should be estimated with zeros included in this calculation by using the \Rcode{useZerosToScale=TRUE} option:

<<eval=FALSE>>=
Conditions = rep(c(1, 2), each= 90)
DataNorm <- SCnorm(MultiCondData, Conditions,
                   OutputName = "MyNormalizedData",
                   SavePDF=TRUE,
                   FilterCellNum = 10,
                   NCores=3,
                   useZerosToScale=TRUE)

@

Generally the definition of condition will be obvious given the experimental
setup. If the data are very heterogenous within an experimental setup it may be
beneficial to first cluster more similar cells into groups and define these as
conditions in SCnorm.

\section{SCnorm: UMI data}
SCnorm may also be applied to UMI data. It is highly recommended to check the
count-depth relationship before and after normalization. In some cases,
it might be desired to adjust the threshold used to decide K, the default value
is .1. This means the largest slope mode must be within .1 of zero (zero
indicates effective normalization), however lowering the threshold may improve results from some
datasets.

If the data have -many- ties (lower coverage UMI datasets), then then consider
setting the option ditherCounts to TRUE (default is FALSE). This
introduces some randomness but results will not change if the command is rerun.

For larger datasets, it may also be desired to increase the speed.
One way to do this is to change the parameter PropToUse. PropToUse controls the proportion of
genes to use for the group fitting, where the 25\% are chosen as those
nearest to the the overall group mode. The default value is 25\%.

<<eval=FALSE>>=
checkCountDepth(Data = umiData, Condition = Conditions,
                OutputName = "check_umi_scData",
                FilterCellProportion = .1, FilterExpression = 2)

DataNorm <- SCnorm(umiData, Conditions,
                   OutputName = "MyNormalizedUMIData",
                   FilterCellNum = 10, PropToUse = .1,
                   Thresh = .05, ditherCounts = TRUE)
@

If the single-cell expression matrix is very sparse then SCnorm may not be appropriate. Currently, SCnorm will issue a 
warning if at least one cell/sample has less than 100 non-zero values or total counts below 10,000. SCnorm will fail if the
filtering criteria or quality of data leaves less then 100 genes for normalization.

\section{Spike-ins}

SCnorm does not require spike-ins, however if high quality spike-ins
are available then they may be use to perform the between condition scaling step. If
useSpikes=TRUE then only the spike-ins will be used to estimate the scaling
factors. If the spike-ins do not span the full range of expression, SCnorm will
issue a warning and will use all genes to scale. SCnorm assumes the spikes-ins are named with the prefix "ERCC-".

<<eval=FALSE>>=
DataNorm <- SCnorm(MultiCondData, Conditions,
                     OutputName = "MyNormalizedData",
                     FilterCellNum = 10, useSpikes=TRUE)
@

\section{Within-sample normalization}

SCnorm allows correction of gene-specific features prior to the between-sample
normalization. We implement the regression based procedure from
Risso et al., 2011. To use this feature you must set withinSample equal to a
vector of gene-specific features, one per gene. This could be anything,
but is often GC-content or gene length.

A function to evaluate the extent of bias in expression related to the gene-specific feature is \Rcode{checkWithinFactor()}.
Genes are split into 4 (default) equally sized groups based on the within sample factor provided. For each cell the median expression of genes in each group is then estimated and plot. The function \Rcode{checkWithinFactor} returns a matrix of the expression medians for each group for all cells.

<<eval=TRUE, fig.height=3.5, fig.width=3.5, fig.align='center'>>=
#Colors each sample:
exampleGC <- runif(dim(ExampleData)[1], 0, 1)
names(exampleGC) <- rownames(ExampleData)
withinFactorMatrix <- checkWithinFactor(ExampleData, withinSample = exampleGC)
#Colors samples by Condition:
Conditions <- rep(c(1,2), each=45) 
withinFactorMatrix <- checkWithinFactor(ExampleData, withinSample = exampleGC,
                   Conditions=Conditions)

str(withinFactorMatrix)
@

<<eval=FALSE>>==
# To run correction use:
DataNorm <- SCnorm(ExampleData, Conditions,
                   OutputName = "MyNormalizedData",
                   FilterCellNum = 10, withinSample = exampleGC)

@

For additional evaluation whether to correct for these features or other options for
correction, see: Risso, D., Schwartz, K., Sherlock, G. \& Dudoit, S. GC-content
normalization for RNA-Seq data. BMC Bioinformatics 12, 480 (2011).



\section{Session info}
Here is the output of sessionInfo on the system on which this document was
compiled:
<<eval=TRUE>>=
  print(sessionInfo())
@

  \vspace{1cm}
%\bibliographystyle{natbib}


%\bibliography{lengetal}

\end{document}
